import { NextResponse } from 'next/server';
import { getAllChevaux, deleteCheval } from '../../lib/db';

// GET - R√©cup√©rer tous les chevaux avec filtres optionnels
export async function GET(request) {
  try {
    // Extraire les param√®tres de recherche
    const { searchParams } = new URL(request.url);
    
    const filters = {
      dateDebut: searchParams.get('dateDebut'),
      dateFin: searchParams.get('dateFin'),
      hippodrome: searchParams.get('hippodrome'),
      critere: searchParams.get('critere')
    };
    
    console.log('üîç R√©cup√©ration des chevaux avec filtres:', filters);
    
    // R√©cup√©rer les chevaux depuis la base de donn√©es
    const chevaux = await getAllChevaux(filters);
    
    // Grouper les chevaux par date et course pour faciliter l'affichage
    const chevauxGroupes = {};
    
    chevaux.forEach(cheval => {
      // S'assurer que la date est au format string ISO (YYYY-MM-DD)
      let dateKey;
      if (cheval.date_course) {
        const dateObj = new Date(cheval.date_course);
        if (!isNaN(dateObj.getTime())) {
          // Formater la date en YYYY-MM-DD
          dateKey = dateObj.toISOString().split('T')[0];
        } else {
          console.error('Date invalide pour le cheval:', cheval.nom_cheval, cheval.date_course);
          dateKey = 'date-invalide';
        }
      } else {
        dateKey = 'sans-date';
      }
      
      // Cr√©er une cl√© unique pour chaque course
      const courseKey = `${cheval.hippodrome}_${cheval.numero_reunion}_C${cheval.numero_course}`;
      
      if (!chevauxGroupes[dateKey]) {
        chevauxGroupes[dateKey] = {};
      }
      
      if (!chevauxGroupes[dateKey][courseKey]) {
        chevauxGroupes[dateKey][courseKey] = {
          date: dateKey, // Utiliser la dateKey format√©e
          hippodrome: cheval.hippodrome,
          reunion: cheval.numero_reunion,
          course: cheval.numero_course,
          heure: cheval.heure_course,
          discipline: cheval.discipline,
          distance: cheval.distance,
          critere_utilise: cheval.critere_utilise,
          fichier_nom: cheval.fichier_nom,
          date_import: cheval.date_import,
          chevaux: []
        };
      }
      
      chevauxGroupes[dateKey][courseKey].chevaux.push({
        id: cheval.id,
        numero: cheval.numero_cheval,
        nom: cheval.nom_cheval,
        age: cheval.age,
        sexe: cheval.sexe,
        def: cheval.def,
        def_1: cheval.def_1,
        def_2: cheval.def_2,
        entraineur: cheval.entraineur,
        pilote: cheval.pilote,
        musique: cheval.musique,
        gains_carriere: cheval.gains_carriere,
        pourcent_g_ch: cheval.pourcent_g_ch,
        pourcent_p_ch: cheval.pourcent_p_ch,
        pourcent_total_ch: cheval.pourcent_total_ch,
        data_complete: cheval.data_complete
      });
    });
    
    // Nettoyer les cl√©s invalides si elles existent
    if (chevauxGroupes['date-invalide']) {
      console.warn('‚ö†Ô∏è Des chevaux avec des dates invalides ont √©t√© trouv√©s');
    }
    if (chevauxGroupes['sans-date']) {
      console.warn('‚ö†Ô∏è Des chevaux sans date ont √©t√© trouv√©s');
    }
    
    // Calculer les statistiques
    const stats = {
      totalChevaux: chevaux.length,
      totalCourses: Object.values(chevauxGroupes).reduce(
        (acc, date) => acc + Object.keys(date).length, 
        0
      ),
      hippodromes: [...new Set(chevaux.map(c => c.hippodrome))].filter(Boolean).sort(),
      dates: Object.keys(chevauxGroupes)
        .filter(d => d !== 'date-invalide' && d !== 'sans-date')
        .sort()
        .reverse()
    };
    
    return NextResponse.json({
      success: true,
      data: chevauxGroupes,
      stats: stats
    });
    
  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration des chevaux:', error);
    return NextResponse.json(
      { 
        error: 'Erreur lors de la r√©cup√©ration des donn√©es',
        details: error.message 
      },
      { status: 500 }
    );
  }
}

// DELETE - Supprimer un cheval (soft delete)
export async function DELETE(request) {
  try {
    // R√©cup√©rer l'ID du cheval √† supprimer
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');
    
    if (!id) {
      return NextResponse.json(
        { error: 'ID du cheval manquant' },
        { status: 400 }
      );
    }
    
    console.log(`üóëÔ∏è Suppression du cheval ID: ${id}`);
    
    // Supprimer le cheval (soft delete)
    const result = await deleteCheval(id);
    
    if (result.success) {
      return NextResponse.json({
        success: true,
        message: 'Cheval supprim√© avec succ√®s'
      });
    } else {
      throw new Error('√âchec de la suppression');
    }
    
  } catch (error) {
    console.error('‚ùå Erreur lors de la suppression:', error);
    return NextResponse.json(
      { 
        error: 'Erreur lors de la suppression',
        details: error.message 
      },
      { status: 500 }
    );
  }
}

// Configuration
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';